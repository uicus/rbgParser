// Chess
// -- No rules about repeating states or tie after given number of turns without pawn moves.
// -- Play is limited to 200 turns.

#anyRook(color) = color~RookMoved, color~RookUnmoved
#majorPieces(color) = anyRook(color), color~Knight, color~Bishop, color~Queen
#singleColorPieces(color) = color~Pawn, color~King, majorPieces(color)
#emptyOrColor(color) = singleColorPieces(color), empty
#allPieces = singleColorPieces(white), singleColorPieces(black)

#players = white (100), black (100)
#pieces = allPieces, empty
#variables = pawnDoubleMove (1), whiteKingMoved (1), blackKingMoved (1), turn (200)

#board = rectangle(up,down,left,right,
         [blackRookUnmoved, blackKnight, blackBishop, blackQueen, blackKing, blackBishop, blackKnight, blackRookUnmoved]
         [blackPawn       , blackPawn  , blackPawn  , blackPawn , blackPawn, blackPawn  , blackPawn  , blackPawn       ]
         [empty           , empty      , empty      , empty     , empty    , empty      ,empty       , empty           ]
         [empty           , empty      , empty      , empty     , empty    , empty      ,empty       , empty           ]
         [empty           , empty      , empty      , empty     , empty    , empty      ,empty       , empty           ]
         [empty           , empty      , empty      , empty     , empty    , empty      ,empty       , empty           ]
         [whitePawn       , whitePawn  , whitePawn  , whitePawn , whitePawn, whitePawn  , whitePawn  , whitePawn       ]
         [whiteRookUnmoved, whiteKnight, whiteBishop, whiteQueen, whiteKing, whiteBishop, whiteKnight, whiteRookUnmoved])

#anySquare = (left* + right*)(up* + down*)
#anyNeighborSquare = (left + right + up + down + (left + right)(up + down))

#diagonalLine =
    (
        (up left {empty})* up left
      + (up right {empty})* up right
      + (down left {empty})* down left
      + (down right {empty})* down right
    )

#parallelLine =
    (
        (up {empty})* up
      + (down {empty})* down
      + (right {empty})* right
      + (left {empty})* left
    )

#knightHop =
    (
        (up^2 + down^2)(left + right)
      + (left^2 + right^2)(up + down)
    )

#captureAnyBy(capturingPiece; opponentColor) = {emptyOrColor(opponentColor)} [capturingPiece]

#pickUpPiece(piece) = {piece}[empty]

#standardMove(piece; movePattern; opponentColor) =
    pickUpPiece(piece)
    movePattern
    captureAnyBy(piece; opponentColor)

#bishopMove(color; opponentColor) = standardMove(color~Bishop; diagonalLine; opponentColor)
#knightMove(color; opponentColor) = standardMove(color~Knight; knightHop; opponentColor)
#queenMove(color; opponentColor) = standardMove(color~Queen; (diagonalLine + parallelLine); opponentColor)

#rookMove(color; opponentColor) =
    pickUpPiece(anyRook(color))
    parallelLine
    captureAnyBy(color~RookMoved; opponentColor)

#isAttackedByBishopOrRookOrQueenOrKingOrPawn(opponentColor; forward; backward) = 
      up ({opponentColor~King} + ({empty} up)* {opponentColor~Queen,anyRook(opponentColor)})
    + down ({opponentColor~King} + ({empty} down)* {opponentColor~Queen,anyRook(opponentColor)})
    + left ({opponentColor~King} + ({empty} left)* {opponentColor~Queen,anyRook(opponentColor)})
    + right ({opponentColor~King} + ({empty} right)* {opponentColor~Queen,anyRook(opponentColor)})
    + forward left ({opponentColor~King,opponentColor~Pawn} + ({empty} forward left)* {opponentColor~Queen,opponentColor~Bishop})
    + forward right ({opponentColor~King,opponentColor~Pawn} + ({empty} forward right)* {opponentColor~Queen,opponentColor~Bishop})
    + backward left ({opponentColor~King} + ({empty} backward left)* {opponentColor~Queen,opponentColor~Bishop})
    + backward right ({opponentColor~King} + ({empty} backward right)* {opponentColor~Queen,opponentColor~Bishop})

#isAttackedByRookOrQueen(opponentColor) = parallelLine{anyRook(opponentColor),opponentColor~Queen}
#isAttackedByBishopOrQueen(opponentColor) = diagonalLine{opponentColor~Bishop,opponentColor~Queen}
#isAttackedByRookOrQueen(opponentColor) = parallelLine{anyRook(opponentColor),opponentColor~Queen}
#isAttackedByKnight(opponentColor) = knightHop{opponentColor~Knight}
#isAttackedByKing(opponentColor) = anyNeighborSquare{opponentColor~King}
#isAttackedByPawn(opponentColor; forward) = (right forward + left forward){opponentColor~Pawn}

#isAttackedBy(opponentColor; forward; backward) = (
        isAttackedByBishopOrRookOrQueenOrKingOrPawn(opponentColor; forward; backward)
//        isAttackedByBishopOrRookOrQueenOrKing(opponentColor)
//        isAttackedByBishopOrQueen(opponentColor)
//      + isAttackedByRookOrQueen(opponentColor)
      + isAttackedByKnight(opponentColor)
//      + isAttackedByKing(opponentColor)
//      + isAttackedByPawn(opponentColor; forward)
    )

#isNotAttackedBy(opponentColor; forward; backward) =
    {! isAttackedBy(opponentColor; forward; backward)}

#checked(color; opponentColor; forward; backward) =
    anySquare {color~King} isAttackedBy(opponentColor; forward; backward)

#standardKingMove(color; opponentColor) =
    anyNeighborSquare
    captureAnyBy(color~King; opponentColor)
    [$ color~KingMoved=1]

#castlingKingMove(forward; backward; color; opponentColor) =
    {$ color~KingMoved==0}
    isNotAttackedBy(opponentColor; forward; backward)
    (
        right {empty} isNotAttackedBy(opponentColor; forward; backward)
        right {empty} [color~King]
        right pickUpPiece(color~RookUnmoved)
        left^2
      + left {empty} isNotAttackedBy(opponentColor; forward; backward)
        left {empty} [color~King]
        left {empty} // Rook CAN pass through an attacked square
        left pickUpPiece(color~RookUnmoved)
        right^3
    )
    [color~RookMoved]
    [$ color~KingMoved=1]

#kingMove(forward; backward; color; opponentColor) =
    (
      pickUpPiece(color~King)
      (
          castlingKingMove(forward; backward; color; opponentColor)
        + standardKingMove(color; opponentColor)
      )
    )

#checkForPromotion(forward; color) =
    (
        {? forward} [color~Pawn]
      + {! forward} [majorPieces(color)]
    )

#standardPawnMove(forward; backward; color; opponentColor) =
    pickUpPiece(color~Pawn)
    (
        // Promotion cannot occur
        //{! backward^2}
        (forward^6 backward^5 {empty} forward {empty})
        //(forward {empty})^2
        [color~Pawn]
        [$ pawnDoubleMove=1]
      + (
            forward ({empty} + (right + left) {singleColorPieces(opponentColor)})
        )
        checkForPromotion(forward; color)
    )

#enPassantPawnMove(forward; color) =
    {$ pawnDoubleMove==1}
    [$ pawnDoubleMove=0]
    (
        // We are sure that adjacent cell is occupied by opponentColor~Pawn, because pawnDoubleMove==1, so do not check it
        right pickUpPiece(color~Pawn) left
      + left pickUpPiece(color~Pawn) right
    )
    [empty]
    forward
    [color~Pawn]

#allMoves(forward; backward; color; opponentColor) =
    (
        [$ pawnDoubleMove=0]
        anySquare
        (
            bishopMove(color; opponentColor)
          + rookMove(color; opponentColor)
          + knightMove(color; opponentColor)
          + queenMove(color; opponentColor)
          + kingMove(forward; backward; color; opponentColor)
          + standardPawnMove(forward; backward; color; opponentColor)
        )
      + enPassantPawnMove(forward; color)
    )  {! checked(color; opponentColor; forward; backward)}
    ->>
    [$ color=50,opponentColor=50] // Draw if reached turn limit
    ->>
    [$ turn=turn+1]
    (
        {! checked(opponentColor; color; backward; forward)}
      + {? checked(opponentColor; color; backward; forward)} [$ opponentColor=0,color=100]
    )
    ->opponentColor

#rules = ->white
    (
        allMoves(up;down;white;black)
        allMoves(down;up;black;white)
    )*
